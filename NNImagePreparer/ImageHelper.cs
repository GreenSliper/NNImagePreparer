using System;
using System.Collections.Generic;
using System.Drawing.Drawing2D;
using System.Drawing.Imaging;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace NNImagePreparer
{
	public static class ImageHelper
	{
		public static byte[] CropImage(byte[] content, int x, int y, int width, int height)
		{
			using (MemoryStream stream = new MemoryStream(content))
			{
				return CropImage(stream, x, y, width, height);
			}
		}

		public static byte[] CropImage(Stream content, int x, int y, int width, int height)
		{
			//Parsing stream to bitmap
			using (Bitmap sourceBitmap = new Bitmap(content))
			{
				//Get new dimensions
				double sourceWidth = Convert.ToDouble(sourceBitmap.Size.Width);
				double sourceHeight = Convert.ToDouble(sourceBitmap.Size.Height);
				Rectangle cropRect = new Rectangle(x, y, width, height);

				//Creating new bitmap with valid dimensions
				using (Bitmap newBitMap = new Bitmap(cropRect.Width, cropRect.Height))
				{
					using (Graphics g = Graphics.FromImage(newBitMap))
					{
						g.InterpolationMode = InterpolationMode.HighQualityBicubic;
						g.SmoothingMode = SmoothingMode.HighQuality;
						g.PixelOffsetMode = PixelOffsetMode.HighQuality;
						g.CompositingQuality = CompositingQuality.HighQuality;

						g.DrawImage(sourceBitmap, new Rectangle(0, 0, newBitMap.Width, newBitMap.Height), cropRect, GraphicsUnit.Pixel);

						return GetBitmapBytes(newBitMap);
					}
				}
			}
		}

		public static byte[] GetBitmapBytes(Bitmap source)
		{
			//Settings to increase quality of the image
			ImageCodecInfo codec = ImageCodecInfo.GetImageEncoders()[4];
			EncoderParameters parameters = new EncoderParameters(1);
			parameters.Param[0] = new EncoderParameter(System.Drawing.Imaging.Encoder.Quality, 100L);

			//Temporary stream to save the bitmap
			using (MemoryStream tmpStream = new MemoryStream())
			{
				source.Save(tmpStream, codec, parameters);

				//Get image bytes from temporary stream
				byte[] result = new byte[tmpStream.Length];
				tmpStream.Seek(0, SeekOrigin.Begin);
				tmpStream.Read(result, 0, (int)tmpStream.Length);

				return result;
			}
		}
		public static Image Resize(Image current, int maxWidth, int maxHeight)
		{
			int width, height;
			#region reckon size 
			if (current.Width > current.Height)
			{
				width = maxWidth;
				height = Convert.ToInt32(current.Height * maxHeight / (double)current.Width);
			}
			else
			{
				width = Convert.ToInt32(current.Width * maxWidth / (double)current.Height);
				height = maxHeight;
			}
			#endregion

			#region get resized bitmap 
			var canvas = new Bitmap(width, height);

			using (var graphics = Graphics.FromImage(canvas))
			{
				graphics.CompositingQuality = CompositingQuality.HighSpeed;
				graphics.InterpolationMode = InterpolationMode.HighQualityBicubic;
				graphics.CompositingMode = CompositingMode.SourceCopy;
				graphics.DrawImage(current, 0, 0, width, height);
			}

			return canvas;
			#endregion
		}

		public static Image ByteArrayToImage(byte[] byteArrayIn)
		{
			MemoryStream ms = new MemoryStream(byteArrayIn);
			Image returnImage = Image.FromStream(ms);
			return returnImage;
		}
		public static byte[] ImageToByteArray(Image image)
		{
			using (var ms = new MemoryStream())
			{
				image.Save(ms, ImageFormat.Jpeg);
				return ms.ToArray();
			}
		}
	}
}
